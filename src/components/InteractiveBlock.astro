---
interface Props {
  id: string;
  title: string;
  type?: 'text' | 'code' | 'qcm';
  question?: string;
  options?: string[];
  placeholder?: string;
}

const { id, title, type = 'text', question, options, placeholder } = Astro.props;
---

<div class="interactive-block bg-primary-50 dark:bg-primary-900/20 border-2 border-primary-200 dark:border-primary-800 rounded-lg p-6 my-6" data-block-id={id}>
  <div class="flex items-start justify-between mb-4">
    <h4 class="text-lg font-semibold text-primary-900 dark:text-primary-100 flex items-center">
      <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
      </svg>
      {title}
    </h4>
    <button 
      class="clear-block-btn text-sm text-primary-700 dark:text-primary-300 hover:text-primary-900 dark:hover:text-primary-100 underline"
      data-block-id={id}
      aria-label={`Effacer la réponse pour ${title}`}
    >
      Effacer
    </button>
  </div>

  {question && (
    <p class="text-secondary-700 dark:text-secondary-300 mb-4 font-medium">
      {question}
    </p>
  )}

  <div class="answer-container">
    {type === 'text' && (
      <textarea
        id={`answer-${id}`}
        class="input-field min-h-[120px] resize-y font-mono text-sm"
        placeholder={placeholder || 'Tapez votre réponse ici...'}
        aria-label={`Réponse pour ${title}`}
      />
    )}

    {type === 'code' && (
      <textarea
        id={`answer-${id}`}
        class="input-field min-h-[200px] resize-y font-mono text-sm bg-secondary-900 text-green-400"
        placeholder={placeholder || '# Écrivez votre code Python ici\n'}
        spellcheck="false"
        aria-label={`Code pour ${title}`}
      />
    )}

    {type === 'qcm' && options && (
      <div class="space-y-3" role="radiogroup" aria-label={question}>
        {options.map((option, index) => (
          <label class="flex items-start p-3 border border-secondary-300 dark:border-secondary-700 rounded-lg hover:bg-white dark:hover:bg-secondary-800 cursor-pointer transition-colors">
            <input
              type="radio"
              name={`qcm-${id}`}
              value={option}
              class="mt-1 mr-3 text-primary-600 focus:ring-primary-500"
            />
            <span class="text-secondary-900 dark:text-secondary-100">{option}</span>
          </label>
        ))}
      </div>
    )}
  </div>

  <div class="mt-4 flex items-center justify-between">
    <span class="saved-indicator text-sm text-green-600 dark:text-green-400 hidden">
      <svg class="w-4 h-4 inline mr-1" fill="currentColor" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
      </svg>
      Sauvegardé
    </span>
    <span class="text-xs text-secondary-500 dark:text-secondary-400">
      Les réponses sont sauvegardées automatiquement
    </span>
  </div>
</div>

<script>
  // Initialisation des blocs interactifs
  document.addEventListener('DOMContentLoaded', () => {
    const blocks = document.querySelectorAll('.interactive-block');
    const pageId = window.location.pathname;

    blocks.forEach((block) => {
      const blockId = block.getAttribute('data-block-id');
      if (!blockId) return;

      const storageKey = `response_${pageId}_${blockId}`;
      const textarea = block.querySelector('textarea');
      const radioGroup = block.querySelector('[role="radiogroup"]');
      const savedIndicator = block.querySelector('.saved-indicator');
      const clearBtn = block.querySelector('.clear-block-btn');

      // Charger la réponse sauvegardée
      const savedResponse = localStorage.getItem(storageKey);
      
      if (textarea && savedResponse) {
        textarea.value = savedResponse;
      } else if (radioGroup && savedResponse) {
        const radio = radioGroup.querySelector(`input[value="${savedResponse}"]`) as HTMLInputElement;
        if (radio) radio.checked = true;
      }

      // Sauvegarder au changement
      const saveResponse = (value: string) => {
        localStorage.setItem(storageKey, value);
        if (savedIndicator) {
          savedIndicator.classList.remove('hidden');
          setTimeout(() => {
            savedIndicator.classList.add('hidden');
          }, 2000);
        }
      };

      if (textarea) {
        textarea.addEventListener('input', (e) => {
          saveResponse((e.target as HTMLTextAreaElement).value);
        });
      }

      if (radioGroup) {
        const radios = radioGroup.querySelectorAll('input[type="radio"]');
        radios.forEach((radio) => {
          radio.addEventListener('change', (e) => {
            saveResponse((e.target as HTMLInputElement).value);
          });
        });
      }

      // Effacer la réponse
      clearBtn?.addEventListener('click', () => {
        if (confirm('Voulez-vous vraiment effacer cette réponse ?')) {
          localStorage.removeItem(storageKey);
          if (textarea) textarea.value = '';
          if (radioGroup) {
            const radios = radioGroup.querySelectorAll('input[type="radio"]') as NodeListOf<HTMLInputElement>;
            radios.forEach((r) => (r.checked = false));
          }
        }
      });
    });
  });
</script>
