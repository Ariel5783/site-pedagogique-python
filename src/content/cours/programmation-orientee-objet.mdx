---
title: "Programmation Orientée Objet (POO)"
level: ["BTS CIEL", "BTS SIO"]
type: "cours"
objectifs:
  - "Comprendre les concepts de la POO"
  - "Créer et utiliser des classes et objets"
  - "Maîtriser l'encapsulation, l'héritage et le polymorphisme"
  - "Appliquer la POO à des cas pratiques"
prerequis:
  - "Fonctions et structures de contrôle"
  - "Listes et dictionnaires"
duree_estimee: "4h00"
auteur: "Eric MORMIN"
updated: "2025-12-14"
mots_cles: ["poo", "classes", "objets", "héritage", "encapsulation"]
---

import InteractiveBlock from '../../components/InteractiveBlock.astro';
import TeacherOnly from '../../components/TeacherOnly.astro';

## Introduction à la POO

La **Programmation Orientée Objet (POO)** est un paradigme de programmation qui organise le code autour d'**objets** plutôt que de fonctions et de logique.

### Concepts fondamentaux

- **Classe** : Modèle ou plan pour créer des objets
- **Objet** : Instance d'une classe
- **Attributs** : Variables qui appartiennent à un objet
- **Méthodes** : Fonctions qui appartiennent à un objet

### Avantages de la POO

✅ **Réutilisabilité** : Code réutilisable via l'héritage  
✅ **Modularité** : Code organisé en modules indépendants  
✅ **Maintenabilité** : Plus facile à maintenir et modifier  
✅ **Abstraction** : Cache la complexité interne

## 1. Classes et Objets

### 1.1 Création d'une classe

Une classe est créée avec le mot-clé `class` :

```python
class Personne:
    """Représente une personne"""
    
    def __init__(self, nom, age):
        """Constructeur de la classe"""
        self.nom = nom
        self.age = age
    
    def se_presenter(self):
        """Méthode pour se présenter"""
        print(f"Je m'appelle {self.nom} et j'ai {self.age} ans.")
```

**Points clés** :
- `__init__` : Méthode spéciale appelée lors de la création d'un objet
- `self` : Référence à l'instance courante
- Attributs : `self.nom`, `self.age`
- Méthode : `se_presenter()`

### 1.2 Création d'objets

```python
# Création d'objets (instances)
personne1 = Personne("Alice", 25)
personne2 = Personne("Bob", 30)

# Appel des méthodes
personne1.se_presenter()  # Je m'appelle Alice et j'ai 25 ans.
personne2.se_presenter()  # Je m'appelle Bob et j'ai 30 ans.

# Accès aux attributs
print(personne1.nom)  # Alice
print(personne2.age)  # 30
```

<InteractiveBlock
  id="classe-simple"
  title="À vous de jouer : Créer une classe Voiture"
  type="code"
  question="Créez une classe Voiture avec marque, modèle et année. Ajoutez une méthode afficher_infos()."
  placeholder="class Voiture:
    def __init__(self, marque, modele, annee):
        # Votre code ici
        pass
    
    def afficher_infos(self):
        # Votre code ici
        pass

# Test
ma_voiture = Voiture('Tesla', 'Model 3', 2023)
ma_voiture.afficher_infos()
"
/>

## 2. Attributs et Méthodes

### 2.1 Attributs d'instance vs attributs de classe

```python
class Etudiant:
    # Attribut de classe (partagé par toutes les instances)
    etablissement = "La Salle Saint-Nicolas"
    
    def __init__(self, nom, promo):
        # Attributs d'instance (propres à chaque objet)
        self.nom = nom
        self.promo = promo

# Utilisation
etud1 = Etudiant("Alice", "BTS CIEL 1")
etud2 = Etudiant("Bob", "BTS CIEL 2")

print(etud1.nom)            # Alice (attribut d'instance)
print(etud1.etablissement)  # La Salle Saint-Nicolas (attribut de classe)
print(Etudiant.etablissement)  # La Salle Saint-Nicolas
```

### 2.2 Méthodes spéciales

Python fournit des méthodes spéciales (dunder methods) :

```python
class CompteBancaire:
    def __init__(self, titulaire, solde=0):
        self.titulaire = titulaire
        self.solde = solde
    
    def __str__(self):
        """Représentation en chaîne de caractères"""
        return f"Compte de {self.titulaire}: {self.solde}€"
    
    def __repr__(self):
        """Représentation pour le débogage"""
        return f"CompteBancaire('{self.titulaire}', {self.solde})"
    
    def __add__(self, montant):
        """Surcharge de l'opérateur +"""
        return CompteBancaire(self.titulaire, self.solde + montant)

# Utilisation
compte = CompteBancaire("Alice", 1000)
print(compte)  # Appelle __str__
print(repr(compte))  # Appelle __repr__

nouveau_compte = compte + 500  # Appelle __add__
print(nouveau_compte)
```

**Méthodes spéciales courantes** :
- `__init__` : Constructeur
- `__str__` : Conversion en string (pour print)
- `__repr__` : Représentation officielle
- `__len__` : Pour `len()`
- `__add__` : Pour `+`
- `__eq__` : Pour `==`

<InteractiveBlock
  id="methodes-speciales"
  title="À vous de jouer : Méthodes spéciales"
  type="code"
  question="Ajoutez __str__ et __len__ à une classe Livre"
  placeholder="class Livre:
    def __init__(self, titre, auteur, pages):
        self.titre = titre
        self.auteur = auteur
        self.pages = pages
    
    def __str__(self):
        # Retourne une description du livre
        pass
    
    def __len__(self):
        # Retourne le nombre de pages
        pass

# Test
livre = Livre('1984', 'George Orwell', 328)
print(livre)
print(f'Nombre de pages: {len(livre)}')
"
/>

## 3. Encapsulation

L'encapsulation permet de **protéger** les données d'un objet.

### 3.1 Attributs privés et publics

```python
class CompteBancaire:
    def __init__(self, titulaire, solde_initial):
        self.titulaire = titulaire  # Public
        self.__solde = solde_initial  # Privé (double underscore)
    
    def deposer(self, montant):
        """Méthode publique pour modifier le solde"""
        if montant > 0:
            self.__solde += montant
        else:
            print("Montant invalide")
    
    def retirer(self, montant):
        """Méthode publique pour retirer de l'argent"""
        if 0 < montant <= self.__solde:
            self.__solde -= montant
        else:
            print("Solde insuffisant ou montant invalide")
    
    def get_solde(self):
        """Getter pour accéder au solde"""
        return self.__solde

# Utilisation
compte = CompteBancaire("Alice", 1000)
compte.deposer(500)
print(compte.get_solde())  # 1500

# ❌ Erreur : attribut privé non accessible
# print(compte.__solde)  # AttributeError
```

### 3.2 Properties (Propriétés)

Les properties permettent d'accéder aux attributs privés de manière contrôlée :

```python
class Rectangle:
    def __init__(self, largeur, hauteur):
        self.__largeur = largeur
        self.__hauteur = hauteur
    
    @property
    def largeur(self):
        """Getter pour largeur"""
        return self.__largeur
    
    @largeur.setter
    def largeur(self, valeur):
        """Setter pour largeur avec validation"""
        if valeur > 0:
            self.__largeur = valeur
        else:
            raise ValueError("La largeur doit être positive")
    
    @property
    def aire(self):
        """Propriété calculée (read-only)"""
        return self.__largeur * self.__hauteur

# Utilisation
rect = Rectangle(10, 5)
print(rect.largeur)  # 10 (appelle le getter)
rect.largeur = 15    # Appelle le setter
print(rect.aire)     # 75 (propriété calculée)
```

## 4. Héritage

L'héritage permet de créer une nouvelle classe basée sur une classe existante.

### 4.1 Héritage simple

```python
class Animal:
    """Classe parent (classe de base)"""
    
    def __init__(self, nom):
        self.nom = nom
    
    def faire_bruit(self):
        print("L'animal fait un bruit")
    
    def se_deplacer(self):
        print(f"{self.nom} se déplace")

class Chien(Animal):
    """Classe enfant (classe dérivée)"""
    
    def faire_bruit(self):
        """Surcharge de la méthode"""
        print(f"{self.nom} aboie : Woof!")
    
    def chercher_balle(self):
        """Nouvelle méthode spécifique au Chien"""
        print(f"{self.nom} court chercher la balle")

class Chat(Animal):
    """Autre classe enfant"""
    
    def faire_bruit(self):
        print(f"{self.nom} miaule : Miaou!")

# Utilisation
chien = Chien("Rex")
chat = Chat("Whiskers")

chien.faire_bruit()      # Rex aboie : Woof!
chat.faire_bruit()       # Whiskers miaule : Miaou!
chien.chercher_balle()   # Rex court chercher la balle
chien.se_deplacer()      # Rex se déplace (hérité)
```

### 4.2 Méthode super()

`super()` permet d'appeler les méthodes de la classe parent :

```python
class Vehicule:
    def __init__(self, marque, vitesse_max):
        self.marque = marque
        self.vitesse_max = vitesse_max
    
    def afficher_infos(self):
        print(f"Marque: {self.marque}")
        print(f"Vitesse max: {self.vitesse_max} km/h")

class Voiture(Vehicule):
    def __init__(self, marque, vitesse_max, nb_portes):
        super().__init__(marque, vitesse_max)  # Appel du constructeur parent
        self.nb_portes = nb_portes
    
    def afficher_infos(self):
        super().afficher_infos()  # Appel de la méthode parent
        print(f"Nombre de portes: {self.nb_portes}")

# Utilisation
voiture = Voiture("Peugeot", 180, 5)
voiture.afficher_infos()
```

<InteractiveBlock
  id="heritage"
  title="À vous de jouer : Héritage"
  type="code"
  question="Créez une classe Employe et une classe Manager qui hérite d'Employe"
  placeholder="class Employe:
    def __init__(self, nom, salaire):
        # Votre code
        pass
    
    def afficher_infos(self):
        # Votre code
        pass

class Manager(Employe):
    def __init__(self, nom, salaire, equipe):
        # Utiliser super()
        pass
    
    def afficher_infos(self):
        # Surcharger et utiliser super()
        pass

# Test
manager = Manager('Alice', 5000, ['Bob', 'Charlie'])
manager.afficher_infos()
"
/>

## 5. Polymorphisme

Le polymorphisme permet aux objets de différentes classes d'être traités de manière uniforme.

```python
class Forme:
    def calculer_aire(self):
        pass

class Rectangle(Forme):
    def __init__(self, largeur, hauteur):
        self.largeur = largeur
        self.hauteur = hauteur
    
    def calculer_aire(self):
        return self.largeur * self.hauteur

class Cercle(Forme):
    def __init__(self, rayon):
        self.rayon = rayon
    
    def calculer_aire(self):
        return 3.14159 * self.rayon ** 2

# Polymorphisme en action
formes = [
    Rectangle(10, 5),
    Cercle(7),
    Rectangle(3, 4)
]

for forme in formes:
    # Même méthode, comportement différent selon la classe
    print(f"Aire: {forme.calculer_aire()}")
```

## 6. Exemple complet : Système de gestion d'étudiants

```python
class Personne:
    """Classe de base"""
    
    def __init__(self, nom, prenom, age):
        self.nom = nom
        self.prenom = prenom
        self.age = age
    
    def __str__(self):
        return f"{self.prenom} {self.nom}, {self.age} ans"

class Etudiant(Personne):
    """Classe dérivée"""
    
    nb_etudiants = 0  # Attribut de classe
    
    def __init__(self, nom, prenom, age, formation):
        super().__init__(nom, prenom, age)
        self.formation = formation
        self.notes = []
        Etudiant.nb_etudiants += 1
    
    def ajouter_note(self, note):
        if 0 <= note <= 20:
            self.notes.append(note)
        else:
            print("Note invalide")
    
    def calculer_moyenne(self):
        if self.notes:
            return sum(self.notes) / len(self.notes)
        return 0
    
    def __str__(self):
        return f"{super().__str__()}, Formation: {self.formation}"
    
    @classmethod
    def get_nb_etudiants(cls):
        return cls.nb_etudiants

# Utilisation
etud1 = Etudiant("Dupont", "Alice", 20, "BTS CIEL")
etud2 = Etudiant("Martin", "Bob", 21, "BTS SIO")

etud1.ajouter_note(15)
etud1.ajouter_note(18)
etud1.ajouter_note(16)

print(etud1)
print(f"Moyenne: {etud1.calculer_moyenne()}")
print(f"Nombre d'étudiants: {Etudiant.get_nb_etudiants()}")
```

## 7. Résumé des concepts POO

### Les 4 piliers de la POO

1. **Encapsulation** : Regrouper données et méthodes, contrôler l'accès
2. **Héritage** : Réutiliser et étendre le code existant
3. **Polymorphisme** : Même interface, comportements différents
4. **Abstraction** : Simplifier les concepts complexes

### Bonnes pratiques

✅ Nommage des classes en **PascalCase** (`MaClasse`)  
✅ Nommage des méthodes en **snake_case** (`ma_methode`)  
✅ Utiliser `__init__` pour initialiser les objets  
✅ Documenter avec docstrings  
✅ Privilégier la composition à l'héritage multiple  
✅ Respecter le principe de responsabilité unique

<TeacherOnly title="Notes pédagogiques POO">

## Points d'attention

- **self** : Concept crucial mais souvent source de confusion
- **Héritage** : Bien expliquer super() et l'ordre de résolution
- **Encapsulation** : Python ne force pas la privacité (convention avec __)
- **Polymorphisme** : Montrer avec des exemples concrets

## Exercices suggérés

1. Créer un système de gestion de bibliothèque
2. Modéliser des comptes bancaires avec héritage
3. Système de gestion d'entreprise (employés, managers, directeurs)
4. Jeu de cartes avec classes Carte, Paquet, Joueur

## Erreurs courantes

- Oubli de `self` dans les méthodes
- Confusion entre attributs de classe et d'instance
- Mauvaise utilisation de `super()`
- Héritage trop profond (préférer la composition)

## Prolongements

- Classes abstraites (module `abc`)
- Héritage multiple
- Métaclasses
- Décorateurs de méthodes (@staticmethod, @classmethod)

</TeacherOnly>
